<!DOCTYPE html>
<html>
  <head>
    <title>Elixir.TartuParking.ModelCase</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/source.css" type="text/css" media="screen" charset="utf-8" />
    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
  </head>

  <body>
    <div id="content">
      <h1>Elixir.TartuParking.ModelCase Coverage Source Code</h1>

      <table class="source">
        <thead>
          <tr>
            <th>Line Number</th><th>Covered Lines</th><th>Source Code</th>
          </tr>
        </thead>
        <tbody>
          <tr class="source"><td class="num"> 1</td>
  <td class="num">7</td>
  <td class="elixir">
    
      <a name="#Elixir.TartuParking.ModelCase"></a>
    
    <pre class="covered">defmodule TartuParking.ModelCase do
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 2</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  @moduledoc """
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 3</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  This module defines the test case to be used by
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 4</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  model tests.
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 5</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 6</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  You may define functions here to be used as helpers in
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 7</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  your model tests. See `errors_on/2`'s definition as reference.
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 8</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 9</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  Finally, if the test case interacts with the database,
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 10</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  it cannot be async. For this reason, every test runs
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 11</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  inside a transaction which is reset at the beginning
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 12</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  of the test unless the test case is marked as async.
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 13</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  """
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 14</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 15</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  use ExUnit.CaseTemplate
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 16</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 17</td>
  <td class="num">4</td>
  <td class="elixir">
    
    <pre class="covered">  using do
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 18</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">    quote do
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 19</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">      alias TartuParking.Repo
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 20</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 21</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">      import Ecto
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 22</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">      import Ecto.Changeset
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 23</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">      import Ecto.Query
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 24</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">      import TartuParking.ModelCase
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 25</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">    end
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 26</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  end
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 27</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 28</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  setup tags do
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 29</td>
  <td class="num">7</td>
  <td class="elixir">
    
    <pre class="covered">    :ok = Ecto.Adapters.SQL.Sandbox.checkout(TartuParking.Repo)
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 30</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 31</td>
  <td class="num">7</td>
  <td class="elixir">
    
    <pre class="covered">    unless tags[:async] do
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 32</td>
  <td class="num">7</td>
  <td class="elixir">
    
    <pre class="covered">      Ecto.Adapters.SQL.Sandbox.mode(TartuParking.Repo, {:shared, self()})
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 33</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">    end
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 34</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 35</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">    :ok
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 36</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  end
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 37</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 38</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  @doc """
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 39</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  Helper for returning list of errors in a struct when given certain data.
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 40</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 41</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  ## Examples
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 42</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 43</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  Given a User schema that lists `:name` as a required field and validates
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 44</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  `:password` to be safe, it would return:
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 45</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 46</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">      iex&gt; errors_on(%User{}, %{password: "password"})
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 47</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">      [password: "is unsafe", name: "is blank"]
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 48</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 49</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  You could then write your assertion like:
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 50</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 51</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">      assert {:password, "is unsafe"} in errors_on(%User{}, %{password: "password"})
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 52</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  """
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 53</td>
  <td class="num"></td>
  <td class="elixir">
    
      <a name="#Elixir.TartuParking.ModelCase.errors_on.2"></a>
    
    <pre class="irrelevant">  def errors_on(struct, data) do
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 54</td>
  <td class="num">0</td>
  <td class="elixir">
    
    <pre class="not_covered">    struct.__struct__.changeset(struct, data)
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 55</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">    |&gt; Ecto.Changeset.traverse_errors(&amp;TartuParking.ErrorHelpers.translate_error/1)
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 56</td>
  <td class="num">0</td>
  <td class="elixir">
    
    <pre class="not_covered">    |&gt; Enum.flat_map(fn {key, errors} -&gt; for msg &lt;- errors, do: {key, msg} end)
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 57</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">  end
</pre>
  </td>
</tr>
<tr class="source"><td class="num"> 58</td>
  <td class="num"></td>
  <td class="elixir">
    
    <pre class="irrelevant">end
</pre>
  </td>
</tr>

        </tbody>
      </table>
    </div>
  </body>
</html>
